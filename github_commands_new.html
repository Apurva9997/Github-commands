<html>
	<head>
        <style>
            table.paleBlueRows {
            font-family: "Times New Roman", Times, serif;
            border: 1px solid #FFFFFF;
            /* width: 350px; */
            /* height: 200px; */
            text-align: center;
            border-collapse: collapse;
            font-size: 14pt;
            }
            table.paleBlueRows td, table.paleBlueRows th {
            border: 1px solid #FFFFFF;
            padding: 3px 2px;
            }
            /* table.paleBlueRows tbody td {
            font-size: 13px;
            } */
            table.paleBlueRows tr:nth-child(even) {
            background: #D0E4F5;
            }
            table.paleBlueRows thead {
            background: #0B6FA4;
            border-bottom: 5px solid #FFFFFF;
            }
            table.paleBlueRows thead th {
            font-size: 17px;
            font-weight: bold;
            color: #FFFFFF;
            text-align: center;
            border-left: 2px solid #FFFFFF;
            }
            table.paleBlueRows thead th:first-child {
            border-left: none;
            }
            table.paleBlueRows tfoot {
            font-size: 14px;
            font-weight: bold;
            color: #333333;
            background: #D0E4F5;
            border-top: 3px solid #444444;
            }
            table.paleBlueRows tfoot td {
            font-size: 14px;
            }
        </style>
    </head>
    <body>
        <table class='paleBlueRows'>
            <thead>
                <tr>
                    <th>
                        Name
                    </th>
                    <th>
                        Command
                    </th>
                    <th>
                        Description
                    </th>
                    <th>
                        Example
                    </th>
                </tr>
        </thead>
        <tbody>
            <tr>
                <td>
                    Git Help
                </td>
                <td>
                    man 'command_goes_here'
                </td>
                <td>
                    Get documentation for a command
                </td>
                <td>
                    man git-log
                </td>
            </tr>
            <tr>
                <td>
                    Git Initialize
                </td>
                <td>
                    git init
                </td>
                <td>
                    git init inside the main directory
                </td>
                <td>
                    git init
                </td>
            </tr>
            <tr>
                <td>
                    Adding files to git repo
                </td>
                <td>
                    git add
                </td>
                <td>
                    Move files to the staging area.
                </td>
                <td>
                    git add
                </td>
            </tr>
            <tr>
                <td>
                    Commiting changes to git
                </td>
                <td>
                    git commit
                </td>
                <td>
                    commit files to the repository.
                </td>
                <td>
                    git add
                </td>
            </tr>
            <tr>
                <td>
                    Comparing the project to the git repo
                </td>
                <td>
                    git diff --cached
                </td>
                <td>
                    Shows the differences in the files b/w current project and the one commited in the repo.
                </td>
                <td>
                    git diff --cached
                </td>
            </tr>
            <tr>
                <td>
                    Viewing project history 1
                </td>
                <td>
                    git log
                </td>
                <td>
                    At any point to view the history of changes.
                </td>
                <td>
                    git log
                </td>
            </tr>
            <tr>
                <td>
                    Viewing project history 2
                </td>
                <td>
                    git log -p
                </td>
                <td>
                    If you also want to see complete diffs at each step.
                </td>
                <td>
                    git log -p
                </td>
            </tr>
            <tr>
                <td>
                    Comparing the project to the git repo
                </td>
                <td>
                    git log --stat --summary
                </td>
                <td>
                    Overview of the change.
                </td>
                <td>
                    git log --stat --summary
                </td>
            </tr>
            <tr>
                <td>
                    Managing branches
                </td>
                <td>
                    git branch branchname
                </td>
                <td>
                    A single Git repository can maintain multiple branches of development.
                    To create a new branch named "experimental".
                </td>
                <td>
                    git branch experimental
                </td>
            </tr>
            <tr>
                <td>
                    Managing branches
                </td>
                <td>
                    git branch
                </td>
                <td>
                    Get a list of all existing branches.
                </td>
                <td>
                    git branch
                    o/p: experimental
                        * master
                </td>
            </tr>
            <tr>
                <td>
                    Managing branches
                </td>
                <td>
                    git checkout branchname
                </td>
                <td>
                    The asterisk marks the branch you are currently on; type
                    $ git checkout experimental
                    to switch to the experimental branch. Now edit a file, commit the change, and switch back to the master branch.
                    At this stage you can have different branches with different commits (or changes).
                </td>
                <td>
                    git checkout experimental
                </td>
            </tr>
            <tr>
                <td>
                    Merging branches
                </td>
                <td>
                    git merge branchname
                </td>
                <td>
                    At this point the two branches have diverged,
                    with different changes made in each. To merge the changes made in experimental into master, run
                    git merge experimental.
                    Note: If the changes don’t conflict, you’re done. If there are conflicts, markers will be left in the problematic files showing the conflict.
                    $ git diff
                    will show this. Once you’ve edited the files to resolve the conflicts,
                    $ git commit -a
                </td>
                <td>
                    git merge experimental
                </td>
            </tr>
            <tr>
                <td>
                    Graphical representation of the resulting history
                </td>
                <td>
                    gitk
                </td>
                <td>
                    Will show a nice graphical representation of the resulting history.
                </td>
                <td>
                    gitk
                </td>
            </tr>
            <tr>
                <td>
                    Delete branch
                </td>
                <td>
                    git branch -d branchname
                </td>
                <td>
                    At any point you can delete the other branch with this command.
                    This command ensures that the changes in the other branch are already in the current branch.
                </td>
                <td>
                    git branch -d experimental
                </td>
            </tr>
            <tr>
                <td>
                    Delete branch (hard)
                </td>
                <td>
                    git branch -D branchname
                </td>
                <td>
                    If you develop on a branch crazy-idea :), then regret it, you can always delete the branch.
                </td>
                <td>
                    git branch -D crazy-idea
            </tr>
            <tr>
                <td>
                    Using Git for collaboration
                </td>
                <td>
                    __
                </td>
                <td>
                    *Suppose that Alice has started a new project with a Git repository in /home/alice/project, and that Bob, who has a home directory on the same machine, wants to contribute.
                    *Bob begins with:
                    git clone /home/alice/project myrepo
                    *This creates a new directory "myrepo" containing a clone of Alice’s repository. The clone is on an equal footing with the original project, possessing its own copy of the original project’s history.
                    *Bob then makes some changes and commits them:
                    (edit files)
                    bob$ git commit -a
                    *When he’s ready, he tells Alice to pull changes from the repository at /home/bob/myrepo. She does this with:
                    alice$ cd /home/alice/project
                    alice$ git pull /home/bob/myrepo master
                    *This merges the changes from Bob’s "master" branch into Alice’s current branch. If Alice has made her own changes in the meantime, then she may need to manually fix any conflicts.
                    *The "pull" command thus performs two operations: it fetches changes from a remote branch, then merges them into the current branch.
                    *Note that in general, Alice would want her local changes committed before initiating this "pull". If Bob’s work conflicts with what Alice did since their histories forked, Alice will use her working tree and the index to resolve conflicts, and existing local changes will interfere with the conflict resolution process (Git will still perform the fetch but will refuse to merge --- Alice will have to get rid of her local changes in some way and pull again when this happens).
                    *Alice can peek at what Bob did without merging first, using the "fetch" command; this allows Alice to inspect what Bob did, using a special symbol "FETCH_HEAD", in order to determine if he has anything worth pulling, like this:
                </td>
                <td>
                    __
                </td>
            </tr>
            <tr>
                <td>
                    Continuation of collaboration
                </td>
                <td>
                    __
                </td>
                <td>
                    alice$ git fetch /home/bob/myrepo master
                    alice$ git log -p HEAD..FETCH_HEAD
                    *This operation is safe even if Alice has uncommitted local changes. The range notation "HEAD..FETCH_HEAD" means "show everything that is reachable from the FETCH_HEAD but exclude anything that is reachable from HEAD". Alice already knows everything that leads to her current state (HEAD), and reviews what Bob has in his state (FETCH_HEAD) that she has not seen with this command.
                    *If Alice wants to visualize what Bob did since their histories forked she can issue the following command:
                    gitk HEAD..FETCH_HEAD
                    This uses the same two-dot range notation we saw earlier with git log.
                    Alice may want to view what both of them did since they forked. She can use three-dot form instead of the two-dot form:
                    $ gitk HEAD...FETCH_HEAD
                </td>
                <td>
                    __
            </tr>
            <tr>
                <td>
                    Continuation of collaboration
                </td>
                <td>
                    __
                </td>
                <td>
                    *This means "show everything that is reachable from either one, but exclude anything that is reachable from both of them".
                    *Please note that these range notation can be used with both gitk and "git log".
                    *After inspecting what Bob did, if there is nothing urgent, Alice may decide to continue working without pulling from Bob. If Bob’s history does have something Alice would immediately need, Alice may choose to stash her work-in-progress first, do a "pull", and then finally unstash her work-in-progress on top of the resulting history.
                    *When you are working in a small closely knit group, it is not unusual to interact with the same repository over and over again. By defining remote repository shorthand, you can make it easier:
                    alice$ git remote add bob /home/bob/myrepo
                </td>
                <td>
                    __
            </tr>
            <tr>
                <td>
                    Continuation of collaboration
                </td>
                <td>
                    __
                </td>
                <td>
                    With this, Alice can perform the first part of the "pull" operation alone using the git fetch command without merging them with her own branch, using:
                    alice$ git fetch bob
                </td>
                <td>
                    __
            </tr>
            <tr>
                <td>
                    Continuation of collaboration
                </td>
                <td>
                    __
                </td>
                <td>
                    Unlike the longhand form, when Alice fetches from Bob using a remote repository shorthand set up with git remote, what was fetched is stored in a remote-tracking branch, in this case bob/master. So after this:
                    alice$ git log -p master..bob/master
                </td>
                <td>
                    __
            </tr>
            <tr>
                <td>
                    Continuation of collaboration
                </td>
                <td>
                    __
                </td>
                <td>
                    *shows a list of all the changes that Bob made since he branched from Alice’s master branch.
                    *After examining those changes, Alice could merge the changes into her master branch:
                    alice$ git merge bob/master
                    *This merge can also be done by pulling from her own remote-tracking branch, like this:
                    alice$ git pull . remotes/bob/master
                    *Note that git pull always merges into the current branch, regardless of what else is given on the command line.
                    *Later, Bob can update his repo with Alice’s latest changes using
                    bob$ git pull
                        
                </td>
                <td>
                    __
            </tr>
            <tr>
                <td>
                    Continuation of collaboration
                </td>
                <td>
                    __
                </td>
                <td>
                    *Note that he doesn’t need to give the path to Alice’s repository; when Bob cloned Alice’s repository, Git stored the location of her repository in the repository configuration, and that location is used for pulls:
                    bob$ git config --get remote.origin.url
                    /home/alice/project
                    (The complete configuration created by git clone is visible using git config -l, and the git-config[1] man page explains the meaning of each option.)
                    *Git also keeps a pristine copy of Alice’s master branch under the name "origin/master":
                    bob$ git branch -r
                        origin/master
                    *If Bob later decides to work from a different host, he can still perform clones and pulls using the ssh protocol:
                    bob$ git clone alice.org:/home/alice/project myrepo
                </td>
                <td>
                    __
            </tr>
        </tbody>
        </table>
    </body>
</html>